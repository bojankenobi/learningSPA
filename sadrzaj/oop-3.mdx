# 1. Polimorfizam: ViÅ¡e Oblika

Polimorfizam na grÄkom znaÄi "imati viÅ¡e oblika". U Javi, polimorfizam nam omoguÄ‡ava da izvrÅ¡imo istu akciju na razliÄite naÄine. Postoje dva glavna tipa polimorfizma:

## 1.1 StatiÄki (Compile-time) Polimorfizam: PreoptereÄ‡enje Metoda (Method Overloading)

Ovo se deÅ¡ava kada u istoj klasi imamo viÅ¡e metoda sa istim imenom, ali razliÄitim parametrima (razliÄit broj parametara, razliÄit tip, ili oboje). Kompajler odluÄuje koju metodu da pozove na osnovu argumenata koje smo prosledili.

```java
class Kalkulator {
    public int saberi(int a, int b) {
        return a + b;
    }
    
    // Ista metoda, ali sa 3 parametra
    public int saberi(int a, int b, int c) {
        return a + b + c;
    }

    // Ista metoda, ali sa double tipom
    public double saberi(double a, double b) {
        return a + b;
    }
}

public class Glavna {
    public static void main(String[] args) {
        Kalkulator k = new Kalkulator();
        System.out.println(k.saberi(2, 3));      // Poziva prvu metodu
        System.out.println(k.saberi(2, 3, 4));  // Poziva drugu metodu
        System.out.println(k.saberi(2.5, 3.5)); // Poziva treÄ‡u metodu
    }
}
```

## 1.2 DinamiÄki (Run-time) Polimorfizam: Redefinisanje Metoda (Method Overriding)

Ovo se deÅ¡ava kada podklasa pruÅ¾i specifiÄnu implementaciju metode koja je veÄ‡ definisana u njenoj nadklasi. Odluka o tome koja metoda Ä‡e se izvrÅ¡iti donosi se u vreme izvrÅ¡avanja programa (run-time), na osnovu tipa objekta.

Ovo je ono Å¡to najÄeÅ¡Ä‡e podrazumevamo pod "polimorfizmom" u OOP kontekstu. KljuÄno je za fleksibilnost i nadogradivost koda.

```java
class Zivotinja {
    public void oglasiSe() {
        System.out.println("Å½ivotinja se oglaÅ¡ava");
    }
}

class Pas extends Zivotinja {
    @Override
    public void oglasiSe() {
        System.out.println("Pas laje: Av av!");
    }
}

public class Glavna {
    public static void main(String[] args) {
        // Upotreba
        Zivotinja z = new Pas(); // z je tipa Zivotinja, ali objekat je Pas
        z.oglasiSe();            // U vreme izvrÅ¡avanja, JVM vidi da je objekat Pas
                                 // i poziva metodu iz klase Pas.
    }
}
```

---

# 2. Apstrakcija: Fokusiranje na Bitno

Apstrakcija je proces sakrivanja implementacionih detalja i prikazivanja samo funkcionalnosti korisniku. Drugim reÄima, korisnik zna Å¡ta objekat radi, ali ne i kako to radi.

> ğŸš— **Dobar primer je voÅ¾nja automobila.** Da biste vozili, morate znati da koristite volan, pedale i menjaÄ (interfejs). Ne morate znati kako motor sa unutraÅ¡njim sagorevanjem radi, kako se snaga prenosi na toÄkove, ili kako radi elektronski sistem ubrizgavanja goriva (implementacija).

### Kako se postiÅ¾e u Javi?
Apstrakcija se u Javi najÄeÅ¡Ä‡e postiÅ¾e koriÅ¡Ä‡enjem:
* **Apstraktnih klasa (Abstract Classes):** Klasa koja se ne moÅ¾e instancirati (ne moÅ¾e se kreirati objekat od nje). MoÅ¾e imati i apstraktne (bez implementacije) i konkretne metode. SluÅ¾i kao osnova za druge klase koje je nasleÄ‘uju.
* **Interfejsa (Interfaces):** Potpuno apstraktan "ugovor" koji definiÅ¡e skup metoda koje klasa mora da implementira. Ne moÅ¾e imati implementaciju metoda (u starijim verzijama Jave).

### ZaÅ¡to je ovo vaÅ¾no?
1.  **Smanjuje sloÅ¾enost:** Fokusiramo se na interakciju sa objektom na viÅ¡em nivou.
2.  **OlakÅ¡ava odrÅ¾avanje:** MoÅ¾emo promeniti internu implementaciju bez promene spoljnog koda koji je koristi.
3.  **PoveÄ‡ava sigurnost:** SpreÄava korisnika da napravi promene koje bi mogle da naruÅ¡e konzistentnost objekta.

## Primer: Apstraktna klasa `Oblik`

DefiniÅ¡emo apstraktnu klasu `Oblik`. Svaki oblik mora imati moguÄ‡nost da izraÄuna svoju povrÅ¡inu, ali ne znamo kako se to radi za "apstraktni" oblik. Zato je metoda `povrsina()` apstraktna, i svaka konkretna klasa koja nasledi `Oblik` mora da pruÅ¾i svoju implementaciju.

```java
// Apstraktna klasa - ne moÅ¾e se kreirati objekat tipa Oblik
abstract class Oblik {
    // Apstraktna metoda - nema telo, samo potpis
    // Svaka podklasa MORA da je implementira
    public abstract double povrsina();

    // Apstraktna klasa moÅ¾e imati i konkretne metode
    public void prikazi() {
        System.out.println("Ovo je neki geometrijski oblik.");
    }
}

class Krug extends Oblik {
    private double poluprecnik = 5.0;
    
    // PruÅ¾amo implementaciju za apstraktnu metodu
    @Override
    public double povrsina() {
        return Math.PI * poluprecnik * poluprecnik;
    }
}

public class Glavna {
    public static void main(String[] args) {
        // GreÅ¡ka! Ne moÅ¾emo kreirati objekat apstraktne klase.
        // Oblik o = new Oblik(); 

        // Ovo je ispravno
        Oblik krug = new Krug();
        krug.prikazi();
        System.out.println("PovrÅ¡ina kruga je: " + krug.povrsina());
    }
}
```

<Quiz pitanje="Å ta od navedenog NE moÅ¾e imati sopstvene objekte (instance)?" opcije="ObiÄna klasa|Apstraktna klasa|Podklasa" tacanOdgovorIndex="1" />

---

# 3. UML: Jezik za Crtanje Softvera

Unified Modeling Language (UML) je standardizovani grafiÄki jezik za vizuelizaciju, specificiranje, konstruisanje i dokumentovanje softverskih sistema. To je kao arhitektonski nacrt za zgradu, samo Å¡to je za softver. PomaÅ¾e nam da planiramo i komuniciramo ideje pre nego Å¡to napiÅ¡emo kod.

Postoji mnogo vrsta UML dijagrama, ali za nas je na poÄetku najvaÅ¾niji Dijagram Klasa (Class Diagram), jer direktno prikazuje strukturu naÅ¡eg OOP koda.

## Dijagram Klasa

Dijagram klasa prikazuje klase u sistemu, njihove atribute, metode i odnose izmeÄ‘u klasa. Osnovni element je pravougaonik podeljen na tri dela:
1.  **Gornji deo:** Ime klase.
2.  **Srednji deo:** Lista atributa.
3.  **Donji deo:** Lista metoda.

**Oznake vidljivosti (Visibility):**
* `+` public: Vidljivo svima.
* `-` private: Vidljivo samo unutar klase.
* `#` protected: Vidljivo unutar klase i u njenim podklasama.

```text
+---------------------------------------+
|              ImeKlase                 |
+---------------------------------------+
| - atribut1: TipPodatka                |
| + atribut2: TipPodatka                |
+---------------------------------------+
| + metoda1(parametar: Tip): PovratniTip|
| - metoda2(): void                     |
+---------------------------------------+
```

### Primer: UML dijagram za klasu `Ucenik`

Ovako bi izgledao UML dijagram za naÅ¡u `Ucenik` klasu sa enkapsulacijom.

```text
+-----------------------------------+
|               Ucenik              |
+-----------------------------------+
| - ime: String                     |
| - ocena: int                      |
+-----------------------------------+
| + setIme(novoIme: String): void   |
| + getIme(): String                |
| + setOcena(novaOcena: int): void  |
| + getOcena(): int                 |
+-----------------------------------+
```
Ovaj dijagram jasno i saÅ¾eto prikazuje sve bitne informacije o klasi `Ucenik`.

## Odnosi IzmeÄ‘u Klasa

Osim nasleÄ‘ivanja, klase mogu biti u razliÄitim odnosima. UML nam pomaÅ¾e da vizuelizujemo te veze.

1.  **Asocijacija ("koristi"):**
    `Klasa A â¯â¯â¯â¯â¯ Klasa B`
    *Student koristi Knjigu. Nezavisni su.*

2.  **Agregacija ("ima"):**
    `Klasa A â—‡â¯â¯â¯â¯â¯ Klasa B`
    *Departman ima Profesora. Profesor moÅ¾e postojati i bez departmana.*

3.  **Kompozicija ("je deo"):**
    `Klasa A â—†â¯â¯â¯â¯â¯ Klasa B`
    *KuÄ‡a se sastoji od Sobe. Soba ne moÅ¾e postojati bez kuÄ‡e.*

